#include <stdio.h>
#include <stdlib.h>
#include <string.h> // strcpy, strlen, menset

#define MAX_PRODUCTS 100
#define MAX_NAME_LENGTH 30 //문자열 길이 제한, 대신 string 사용가능

// 제품 분류 정보
typedef struct {
    int id;
    int stock_qty;
    int sales_qty;
    char name[MAX_NAME_LENGTH];
} Product;

// ID로 상품 인덱스를 찾는 함수
int find_product_index(Product products[], int count, int id) {
    for (int i = 0; i < count; i++) {
        if (products[i].id == id) {
            return i; // 찾았을 경우 인덱스 반환
        }
    }
    return -1; // 찾지 못했을 경우 -1 반환
}

// 재고 추가 함수
void add_stock(Product products[], int *count) {
    int choice;
    printf("입고(입력)수량 입력 : 전체 상품 입고수량 입력 1, 개별 상품 입력 2 를 선택\n");
    printf("> (입력) ");
    scanf("%d", &choice);

    if (choice == 1) {
    printf("총 %d개 상품의 입고수량을 순서대로 입력하세요 (띄어쓰기로 구분)\n", *count);
    printf("> (입력) ");
    for (int i = 0; i < *count; i++) {
        int stock_to_add = 0;
        scanf("%d", &stock_to_add); // 띄어쓰기로 구분된 숫자를 순서대로 읽어들임

        if (stock_to_add >= 0) {
            products[i].stock_qty += stock_to_add;
        } else {
            // 음수 입력 시 해당 상품은 건너뜀
            printf("상품 ID %d에 대한 입력값이 음수이므로 재고를 추가하지 않습니다.\n", products[i].id);
        }
    }
    printf("모든 상품의 재고가 업데이트되었습니다.\n");
}
    else if (choice == 2) {
        int id, stock_qty;
        printf("(입력)상품ID : ");
        scanf("%d", &id);

        int index = find_product_index(products, *count, id);

        // 상품이 이미 존재하면, 해당 상품에 재고만 추가
        if (index != -1) {
            printf("(입력)입고수량 : ");
            scanf("%d", &stock_qty);
             if (stock_qty < 0) {
                printf("입고수량은 0보다 커야 합니다.\n");
                return;
            }
            products[index].stock_qty += stock_qty;
            printf("상품 ID %d에 %d의 재고가 추가되었습니다.\n", id, stock_qty);
        } else { // 상품이 존재하지 않으면, 새 상품으로 추가
            if (*count < MAX_PRODUCTS) {
                printf("새로운 상품입니다. 상품 ID %d를 추가합니다.\n", id);
                printf("(입력)입고수량 : ");
                scanf("%d", &stock_qty);
                if (stock_qty < 0) {
                    printf("입고수량은 0보다 커야 합니다.\n");
                    return;
                }
                // 배열의 마지막에 새 상품 정보 저장
                products[*count].id = id;
                products[*count].stock_qty = stock_qty;
                products[*count].sales_qty = 0; // 신규 상품이므로 판매량은 0
                (*count)++; // 전체 상품 개수 1 증가
                printf("신규 상품 ID %d가 추가되었고, %d의 재고가 입고되었습니다.\n", id, stock_qty);
            } else {
                printf("더 이상 새로운 상품을 추가할 수 없습니다. (최대 %d개)\n", MAX_PRODUCTS);
            }
        }
    } else {
        printf("잘못된 선택입니다.\n");
    }
}

// 판매 기록 함수
void record_sale(Product products[], int count) {
    int choice;
    printf("판매(출력)판매수량 입력 : 전체 상품 판매수량 입력 1, 개별 상품 입력 2 를 선택\n");
    printf("> (입력) ");
    scanf("%d", &choice);

    if (choice == 1) {
        int total_sale;
        printf("전체 판매수량을 입력해주세요 : ");
        scanf("%d", &total_sale);
        if (total_sale < 0) {
            printf("판매수량은 0보다 커야 합니다.\n");
            return;
        }
        for (int i = 0; i < count; i++) {
            if (products[i].stock_qty >= total_sale) {
                products[i].stock_qty -= total_sale;
                products[i].sales_qty += total_sale;
            } else {
                printf("상품 ID %d의 재고가 부족하여 판매를 완료할 수 없습니다.\n", products[i].id);
            }
        }
        printf("모든 상품의 판매가 기록되었습니다.\n");
    } else if (choice == 2) {
        int id, sales_qty;
        printf("(입력)상품ID : ");
        scanf("%d", &id);
        int index = find_product_index(products, count, id);
        if (index != -1) {
            printf("(입력)판매수량 : ");
            scanf("%d", &sales_qty);
            if (sales_qty < 0) {
                printf("판매수량은 0보다 커야 합니다.\n");
                return;
            }
            if (products[index].stock_qty >= sales_qty) {
                products[index].stock_qty -= sales_qty;
                products[index].sales_qty += sales_qty;
                printf("상품 ID %d에 %d의 판매가 기록되었습니다.\n", id, sales_qty);
            } else {
                printf("상품 ID %d의 재고(%d)가 부족하여 판매를 완료할 수 없습니다.\n", id, products[index].stock_qty);
            }
        } else {
            printf("존재하지 않는 상품 ID입니다.\n");
        }
    } else {
        printf("잘못된 선택입니다.\n");
    }
}

// 상품 재고 및 판매 현황 표시 함수
void display_status(Product products[], int count) {
    if (count == 0) {
        printf("표시할 상품이 없습니다.\n");
        return;
    }

    int total_stock = 0;
    int total_sales = 0;
    
    int most_sold_index = 0; // 첫 번째 상품을 최다 판매 상품으로 가정하고 시작
    int least_sold_index = 0; // 첫 번째 상품을 최소 판매 상품으로 가정하고 시작
    
    for (int i = 0; i < count; i++) {
        total_stock += products[i].stock_qty;
        total_sales += products[i].sales_qty;
        
        if (products[i].sales_qty > products[most_sold_index].sales_qty) {
            most_sold_index = i;
        }
        
        if (products[i].sales_qty < products[least_sold_index].sales_qty) {
            least_sold_index = i;
        }
    }
    
    printf("\n--- 상품 현황 ---\n");
    printf("총 재고수량 : %d\n", total_stock);
    printf("총 판매량 : %d\n", total_sales);
    
    if (total_sales > 0) {
        printf("가장 많이 판매된 상품 : ID %d, 판매량 %d\n", 
               products[most_sold_index].id, products[most_sold_index].sales_qty);
        
        printf("가장 적게 판매된 상품 : ID %d, 판매량 %d\n", 
               products[least_sold_index].id, products[least_sold_index].sales_qty);
    } else {
        printf("판매 기록이 없습니다.\n");
    }
    printf("----------------------\n");

    // --- ID별 재고 현황 ---
    printf("\n--- ID별 재고 현황 ---\n");
    if (count == 0) {
        printf("등록된 상품이 없습니다.\n");
    } else {
        for (int i = 0; i < count; i++) {
            printf(" - 상품 ID %d : %d개\n", products[i].id, products[i].stock_qty);
        }
    }
    printf("--------------------\n");
}

void input_product_name(Product products[], int count) {
    char temp_name[MAX_NAME_LENGTH];
    int c;

    printf("\n4 <<상품명입력 실행\n");
    
    for (int i = 0; i < count; i++) {
        printf("(출력) ID %d 상품명 : (입력)", products[i].id);
        
        // 상품명 입력 (MAX_NAME_LENGTH - 1) 문자로 제한: 30-1=29자
        if (scanf("%29s", temp_name) == 1) {  
            strcpy(products[i].name, temp_name);
            printf("(%s)\n", products[i].name); // 입력된 상품명 에코 출력
        } else {
            printf("잘못된 입력입니다. 재시작이 필요합니다.\n");
            break;
        }
    }
}

int main() {
    Product products[MAX_PRODUCTS];
    int product_count = 0;
    int choice;

    // 인덱스 초기화
    products[0] = (Product){1, 0, 0};   strcpy(products[0].name, "상품명 미등록"); //strcpy 문자열 복사사
    products[1] = (Product){2, 0, 0};   strcpy(products[1].name, "상품명 미등록");
    products[2] = (Product){3, 0, 0};   strcpy(products[2].name, "상품명 미등록");
    products[3] = (Product){4, 0, 0};   strcpy(products[3].name, "상품명 미등록");
    products[4] = (Product){5, 0, 0};   strcpy(products[4].name, "상품명 미등록");
    product_count = 5;

    do {
        printf("\n원하는 메뉴를 선택하세요.(1. 입고, 2. 판매, 3. 상품현황, 4. 상품명 입력, 5. 종료)\n");
        printf("> ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                add_stock(products, &product_count);
                break;
            case 2:
                record_sale(products, product_count);
                break;
            case 3:
                display_status(products, product_count);
                break;
            case 4:
                input_product_name(products, product_count);
                break;
            case 5:
                printf("프로그램을 종료합니다.\n");
                break;
            default:
                printf("잘못된 선택입니다. 다시 시도해주세요.\n");
                break;
        }
    } while (choice != 4);

    return 0;
}
